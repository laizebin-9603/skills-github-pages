---
layout: post
title: "Java Atomic"
date: 2025-05-22 15:30:00 +0800
categories: [JUC]
tags: [java]
---

## Atomic
在 Java 中，java.util.concurrent.atomic 包提供了多种原子操作类，如 AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference 等。这些类允许以原子方式执行某些操作，而无需显式地使用锁来保证线程安全。

### 定义
+ 原子类主要依赖于硬件层面的原子操作指令（如 CAS，Compare And Swap 或 Compare And Set）来实现无锁的同步机制
+ CAS 是一种乐观锁策略，它包括三个操作数：内存位置（V）、预期原值（A）和新值（B）。只有当内存位置处的值与预期原值相匹配时，才会将该位置的值更新为新值；否则不进行任何操作，并返回当前值。
+ 这种机制可以避免传统锁带来的高开销和死锁问题。

### 原理详解
+ 保证原子性：对 CAS 操作的支持。例如，在 AtomicInteger 中，compareAndSet(int expect, int update) 方法尝试将当前值与预期值比较，如果相等，则用新值替换旧值。这个过程是在硬件级别上完成的，保证了操作的原子性
+ 保证可见性：原子类还确保了内存可见性。也就是说，一旦某个线程修改了共享变量的值，其他线程能够立即看到这个修改。

### 其他问题
+ 引入了 ABA 问题，即一个值从 A 变为 B 再变回 A，这可能导致 CAS 认为没有发生过变化。
+ 为了应对这种情况，Java 提供了 AtomicStampedReference 和 AtomicMarkableReference 来追踪引用的变化次数或标记位，从而避免 ABA 问题的影响
