---
layout: post
title: "Redis"
date: 2025-05-13 14:01:00 +0800
categories: [redis]
tags: [java]
---

#### Redis的定位于特性
##### SQL与NoSQL
    1. <font style="color:#DF2A3F;">关系型数据库</font>特点：
        1. 以表格的形式，基于行存储数据，是一个二维的模式
        2. 存储的是结构化的数据，数据存储有固定的模式，数据需要适应表结构
        3. 表与表之间存在关联
        4. 大部分关系型数据库都支持SQL（结构化查询语言）的操作，支持复杂的关联查询
        5. 通过事务（ACID酸）来提供严格或实时的数据一致性
    2. 关系型数据库的一些限制
        1. 实现扩容的话，只能<font style="color:#DF2A3F;">垂直扩容</font>，比如磁盘限制了数据存储，就扩大磁盘容量通过推硬件的方式，不支持动态扩容。水平扩容需要复杂的技术实现，比如分库分表
        2. 表结构修改困难，存储的数据格式也会收到限制
        3. 关系型数据库通常会把数据持久化到磁盘，在高并发和搞数据量的情况下，磁盘的读写压力会比较大
    3. <font style="color:#DF2A3F;">非关系型数据库</font>的特点：
        1. 我们一般把它叫做“non-relational”或者“Not Only SQL”，NoSQL不提供SQL（Structure Query Language 结构化查询语言）
        2. 特点：
            1. 存储非结构化的数据，比如文本、图片、音频、视频；
            2. 表与表之间没有关联，可扩展性强；
            3. 保证数据的最终一致性，遵循BASE理论；Basically Available（基本可用）；Soft-state（软状态）；Eventually Consistent（最终一致性）
            4. 支持海量数据的存储和高并发的高效读写
            5. 支持分布式，能够对数据进行分片存储，扩缩容简单
        3. 常见的非关系型数据库
            1. KV存储：Redis和MemCached
            2. 文档存储：MongoDB
            3. 列存储：HBase
            4. 图存储：Neo4j
            5. 对象存储：
        4. NewSQL：结合了SQL和NoSQL的特性，例如TiDB（PingCAP）、ScaleDB
    4. **<font style="color:#DF2A3F;">Memcached和Redis的主要区别是什么</font>****？**
        1. Memcached只存储KV、没有持久化机制、不支持主从复制、是多线程的

#### Redis基本数据类型
Redis默认有16个库（0-15）可在配置文件中修改，redis的存储我们叫做key-value存储，或者叫字典结构。key的最大长度限制是512M

##### String 类型
    1. 可以用来存储int（整数）、float（单精度浮点数）、String（字符串）
    2. 数据模型
        1. redis 最外层是一个redisDb结构体，里面放的是dict，定义如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735889256023-8d190f3a-e77d-4a16-a679-6e2eb3dff347.png)
        2. 在redis中每个键值对都是一个dictEntry，其中，key存储的是关键字定义，val存储是value定义，next指向下一个键值对，结构如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735889138499-f529032f-c8de-4cb2-80ac-b805124ae014.png)
        3. 以set hello world为例
            1. 因为key是字符串，redis自己实现了一个字符串类型，叫做SDS，所以hello 指向SDS的结构。
            2. value是world，也是一个字符串，但是没有直接指向SDS，而是存储在redisObject中。<font style="color:#DF2A3F;">5种常见的数据类型的value都是通过redisObject存储，最终redisObject再通过指针指向一个实际的数据结构</font>，如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735890087552-67dc84c0-2567-45f9-8480-bf41796bc3b0.png)
            3. redisObject定义：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735890140660-c009bb0f-1cae-4405-837e-ce9b844cce9b.png)
            4. redis中<font style="color:#DF2A3F;">string类型实际对外都是string且用的string命令，但是内部却又3中不同的编码</font>：
                1. <font style="color:#DF2A3F;">int</font>，存储8个字节的长整型（long，2^64-1）
                2. <font style="color:#DF2A3F;">embstr</font>，代表embstr格式的SDS，存储小于44个字节的字符串
                3. <font style="color:#DF2A3F;">raw</font>，存储大于44个字节的字符串
            5. 常见问题：
                1. <font style="color:#DF2A3F;">SDS是什么？</font>
                    1. 是redis中字符串的实现，Simple Dynamic String，简单动态字符串。本质上还是字符串数组，但是多了一些长度等等定义，如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735890861546-48ace0fa-63a5-441a-8d17-a884742a3a50.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735890894890-ef2c320a-e023-47c1-beea-47c72e330f67.png)
                2. <font style="color:#DF2A3F;">为什么redis要用SDS实现字符串</font>？
                    1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735891227710-2e0d4c4c-d9b3-487a-8699-176e47c0781a.png)
                3. <font style="color:#DF2A3F;">embstr和raw编码的区别？为什么要为不同的大小设计不同的编码</font>？
                    1. embstr的使用只分配一次内存空间（因为redisObject和SDS是连续的），而raw需要分配两次内存空间（分别为redisObject和SDS分配空间）。
                    2. 与raw相比，embstr的好处是在创建时少分配一次空间，删除时少分配一次空间。而且数据是连在一起方便寻找。
                    3. embstr的坏处，字符串的长度增加时需要重新分配内存，redisObject和SDS都需要重新分配，因此redis中embstr实现为只读，这种编码的内容是不能修改的
                4. <font style="color:#DF2A3F;">int和embstr什么时候转为raw</font>？
                    1. int数据不再是整数-----raw
                    2. int大小超过了long的范围（2^63-1）-----embstr
                    3. embstr字节超过了44字节-----raw
                5. <font style="color:#DF2A3F;">明明没有超过44字节，为什么变成了raw</font>？
                    1. 前面说过，对于embstr，由于实现只是可读的，因此在对embstr对像进行修改时都会先转化为raw再进行修改。因此，<font style="color:#DF2A3F;">只要是修改embstr对象，随后都会变成raw，无论是否到达了44个字节</font>
                6. <font style="color:#DF2A3F;">当长度小于阈值时，会还原吗</font>？
                    1. 不会，编码转换在redis写入数据时完成，且转换过程不可逆，只能从小内存编码到大内存编码转换
                7. <font style="color:#DF2A3F;">为什么要对底层的数据结构使用redisObject进行一层封装呢</font>？
                    1. 无论是设计redisObject还是设计这么多的SDS，都是为了在存储不同的内容选择不同的存储方式，这样可以尽可能的节省内存空间和提升查询速度

##### Hash 类型
    3. Hash用来存储多个无序的键值对。**<font style="color:#DF2A3F;">最大的存储数量2^32（大概40亿左右）</font>**；<font style="color:#DF2A3F;">注意hash的value只能存储字符串，不能嵌套其他类型</font>；<font style="color:#DF2A3F;">field不能单独设置过期时间</font>；
    4. 数据模型
        1. Hash类型的底层使用两种数据结构实现：<font style="color:#DF2A3F;">ziplist</font> 和 <font style="color:#DF2A3F;">hashtable</font>
            1. <font style="color:#DF2A3F;">ziplist是一个经过特殊编码的，由连续的内存块组成的</font>**<font style="color:#DF2A3F;">双向链表</font>**。但是他<font style="color:#DF2A3F;">不存储上一个节点和下一个节点的指针。</font>而是**<font style="color:#DF2A3F;">存储上一个节点的长度和当前节点的长度</font>**。这样读写可能会慢一点，但是节省内存。![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735894979871-0c6950c3-c75a-45dd-8c83-38840622accd.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735894999802-983cae1b-55d0-46b0-a907-d4132c0c1214.png)
                1. **<font style="color:#DF2A3F;">什么时候使用ziplist存储</font>****？**当hash对象同时满足以下条件时，使用ziplist编码：
                    1. hash对象保存的键值对数量<512个
                    2. 所有键值对的键和值的字符串长度都<64字节（一个英文字母一个字节）
            2. hashtable数据结构
                1. <font style="color:#DF2A3F;">如果超过上面的阈值的任何一个，存储结构就会转化为hashtable</font>
                2. **<font style="color:#DF2A3F;">hashtable的本质就是一个KV的结构，是一个数组 + 链表的结构！！！</font>**
                3. 前面我们知道redis的KV结构是都是通过dictEntry来实现的。但是，在hashtable中，又对dictEntry进行了多层封装。从最高层到最底层：dict->dictht->dictEntry，各个数据结构的定义如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735896626844-0fd20e82-cce6-4bbc-b000-c6ea31b7e011.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735896642749-2f1ed045-1db3-440b-8e67-d70f83d8f356.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735896649668-13c9e063-88b7-47df-9fa1-f2c4f2bd6500.png)
                4. 整体数据结构就是数组+链表：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735896721443-631a0705-4261-4cee-aae4-46082b62e671.png)
                5. 问题：
                    1. **<font style="color:#DF2A3F;">为什么要定义两个哈希表（dictht[2]）,其中一个不用呢</font>**？hash默认使用ht[0]，ht[1]不会分配空间和初始化。**<font style="color:#DF2A3F;">ht[1]用来扩容迁移</font>**，具体如下：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735897127325-f9442528-4bb9-48a5-adf4-0946700f4854.png)
                    2. <font style="color:#DF2A3F;">什么时候触发扩容</font>？
                        1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735897217735-f36027e3-dbd3-44e7-ab91-da620fea1ddb.png)<font style="color:#DF2A3F;">具体和HashMap一样，由扩容因子控制</font>

##### List 集合类型
    5. <font style="color:#DF2A3F;">存储有序的字符串（从左到右），元素可以重复，最大的存储数量2^32-1（40亿左右）</font>
    6. 数据模型：
        1. 3.2版本后统一用quicklist来存储。**<font style="color:#DF2A3F;">quicklist存储了一个双向链表</font>**，每个节点都是一个ziplist![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735898593182-c78cae5a-e077-4dab-b93e-58addd1bb34e.png)
        2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735898640937-1ea0b93b-3012-41cb-bd07-4cd9dc9c9487.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735898655281-9049013a-210d-43b7-a87f-33d951898186.png)

##### Set 集合类型
    1. <font style="color:#DF2A3F;">Set存储String类型的无序集合，最大存储数量2^32-1（40亿左右）</font>
    2. 数据模型：
        1. Redis使用intset或者hashtable存储set
            1. 如果数据都是整数类型就用intset类型，否则用hashtable（数组+链表）；如果元素超过512个也会用hashtable存储
        2. 

##### Zset 有序集合
    3. <font style="color:#DF2A3F;">Zset存储有序的元素，每个元素都有个score，按照score从小到大排名</font>。**<font style="color:#DF2A3F;">score相同时，按照key的ASCLL码排序</font>**。
    4. 数据结构对比：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735962381693-dd59b184-9c53-4c38-859b-c22751c8094d.png)
    5. 默认使用ziplist编码，在ziplist内部，按照score排序递增来存储。插入的时候要移动之后的数据。
    6. **<font style="color:#DF2A3F;">如果元素数量大于等于128个，或者任一member长度大于等于64字节，则使用skiplist + dict存储</font>**
    7. <font style="color:#DF2A3F;">什么事skiplist（跳表）</font>？
        1. 使用有序链表的问题？我们查找某个元素时，需要从头到尾逐个比较，时间复杂度O(n)，当我们要插入时，同样要经历同样的过程。因此，skiplist可以解决上述问题。
        2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735963682768-389b0847-038a-459a-97dc-a6c304cc1b13.png)
        3. 查找过程：
            1. 当我们查找数据时，可以先沿着新链表查找。当碰到比待查找数据大的节点，再到下层查找。
            2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735963952593-31cc97a5-1a90-4951-b082-2c798398783b.png)
            3. 总结，这个查找过程中，<font style="color:#DF2A3F;">由于新增指针我们不需要与链表每个节点逐个比较了，需要比较的节点大概只有原来的一半，这就是跳表</font>。<font style="color:#DF2A3F;">为什么不用AVL树或者红黑树？因为跳表更简洁</font>。
1. <font style="color:#DF2A3F;">总结</font>：
    1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1735964161582-ebf8af64-754d-4906-ae54-6db5a6849204.png)

#### Redis原理
##### Redis支持发布订阅模式
    1. 略

##### Redis事务
    1. Redis的单个命令是原子性的，要么成功要么失败，不存在并发干扰问题。如果涉及多个命令，需要把多个命令作为一个不可分割的处理序列，Redis提供事务的功能：
        1. 按进入队列的顺序进行
        2. 不会收到其他客户端请求的影响
        3. 事务不能嵌套，多个multi命令效果一样
    2. Redis的事务涉及四个命令，multi（开启事务）、exec（执行事务）、discard（取消事务）、watch（监视）
        1. 通过multi命令开启事务。multi执行后，客户端可以继续向服务器发送任意多条命令，不会立即执行而是被放到一个队列。
        2. 执行exec时，所有队列中命令才会被执行；如果没有执行exec，所有命令都不会被执行
        3. discard可以清空事务队列，放弃执行
        4. watch命令，防止事务过程中某个key的值被其他客户端请求修改，带来非预期的结果。即多个客户端更新变量的时候，会跟原值比较，只有他没有被其他线程修改的情况下才更新成新值。
            1. 我们可以用watch监视一个或多个key，如果开启事务后，至少有一个被监视的key键在exec执行之前被修改了，那么整个事务都会被取消
            2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736071153335-b6475332-2024-46dd-9fee-a5dd99fae74f.png)
        5. 事务可能遇到的问题
            1. 在执行exce之前发生错误，例如语法错误，包括参数名，参数数量（编译错误）等。<font style="color:#DF2A3F;">事务会被拒绝执行，队列中所有命令都不会执行。</font>
            2. **<font style="color:#DF2A3F;">在执行exce之后发生错误，例如数据类型错误</font>**（运行时错误）等。**<font style="color:#DF2A3F;">只有错误的命令没有被执行，但是其他命令没有被影响</font>**
            3. <font style="color:#000000;">我们没发用Redis的这种事务机制来实现原子性，保证数据一致性。</font>

##### Lua脚本
    1. 使用Lua脚本来执行Redis命令为好处：
        1. **<font style="color:#DF2A3F;">一次发送多个命令，减少网络开销</font>**
        2. Redis会将整个脚本作为一个整体执行，不会被其他请求打断，**<font style="color:#DF2A3F;">保持原子性</font>**
        3. 对于复杂的组合命令，我们可以放在文件中，**<font style="color:#DF2A3F;">实现命令复用</font>**
    2. Lua使用技巧：
        1. <font style="color:#DF2A3F;">缓存Lua脚本</font>。在脚本比较长的情况下，每次调用脚本都需要把整个脚本都传给Redis服务，会产生较大的网络开销。解决这个问题，Redis可以缓存Lua脚本并生成SHA1摘要码，后面可以通过摘要码来执行Lua脚本。两个命令：
            1. script load "return 'Hello World'"
            2. evalsha "摘要码"
        2. 脚本超时。**<font style="color:#DF2A3F;">脚本执行有一个超时时间，默认为5秒钟</font>**。超过5秒钟，其他客户端命令不会等待，直接返回“BUSY”错误。这样也不行，不能一直拒绝其他客户端命令执行，提供两个命令：
            1. script kill，终止脚本的执行，但是遇见set、del命令，会返回UNKILLABLE错误。原因是为了保证脚本运行的原子性。
            2. 遇见上面的情况只能通过shutdown nosave 命令，直接把Redis服务停掉。

##### Redis为什么这么快
    1. Redis一般情况下支持并发大概10万QPS左右
    2. **<font style="color:#DF2A3F;">Redis快主要包括以下3点：</font>**
        1. **<font style="color:#DF2A3F;">纯内存结构</font>**
            1. KV结构的内存数据库，时间复杂度O(1)。
        2. **<font style="color:#DF2A3F;">请求处理单线程，处理客户端请求是单线程的</font>**，这样的好处：
            1. 没有创建线程，销毁线程带来的消耗
            2. 避免了上下文切换导致的CPU消耗
            3. 避免线程之间带来的竞争问题，例如加锁释放锁等等
        3. **<font style="color:#DF2A3F;">I/O多路复用机制</font>**
            1. 基本原理就是不再是由应用程序自己监控连接，而是由内核替应用程序监视文件描述符
            2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736149832037-ab93c33c-6009-4ea5-b2ed-e15a1eff1122.png)
            3. 常见的多路复用器：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736149933274-5d2a786e-2b61-4699-8a34-d5b518dc482f.png)

##### 内存回收
    1. **<font style="color:#DF2A3F;">过期策略</font>**
        1. 立即过期（主动淘汰），每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期数据，对内存友好；但是会占用大量的CPU资源去处理过期数据，从而会影响缓存的响应时间和吞吐量
        2. 惰性过期（被动淘汰），只有访问一个key时，才会判断该key是否过期，过期则清除。该策略可以最大化地节省CPU资源，对内存非常不友好。
        3. 定期过期，每隔一段时间会扫描一定数据库的expires字典中的一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。
        4. 总结：<font style="color:#DF2A3F;">Redis中同时使用了惰性过期和定期过期两种过期策略，并不是实时地清除过期key</font>
    2. 淘汰策略
        1. 前提：Redis内存淘汰策略是指，内存使用达到最大的内存极限时，需要使用淘汰算法来清理掉哪些数据，以保证新数据的存入。
        2. 最大内存设置：maxmemory，如果不设置或者设置为0，32位系统最多使用3GB内存，64位系统不限制内存
        3. **<font style="color:#DF2A3F;">淘汰策略，大概分为几种策略</font>**
            1. <font style="color:#DF2A3F;"></font>**<font style="color:#DF2A3F;">LRU，最近最少使用</font>**。判断最近被使用的时间，目前最远的数据优先被淘汰
            2. **<font style="color:#DF2A3F;">LFU，最不常用，按照使用频率删除</font>**
            3. **<font style="color:#DF2A3F;">random，随机删除</font>**
            4. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736156965734-0127d609-c862-4fa7-9d43-b0742901a10b.png)
            5. **<font style="color:#DF2A3F;">总结：noeviction默认策略，不删除任何数据，决绝所有写入操作比返回OOM</font>**
            6. LRU原理：<font style="color:#DF2A3F;">略</font>
            7. LFU原理：<font style="color:#DF2A3F;">略</font>

##### 持久化机制
    3. **<font style="color:#DF2A3F;">Redis提供两种持久化方案，RDB快照和AOF</font>**。持久化是Redis和Memcache的主要区别之一
    4. **<font style="color:#DF2A3F;">RDB，是Redis默认的持久化方案</font>**（如果开启了AOF，优先使用AOF）。当满足一定的条件，会把内存中的数据写入磁盘，生成一个快照文件dump.rdb。
        1. RDB触发
            1. 自动触发
                1. 配置规则触发，redis.conf，定义了触发把数据保存在磁盘的触发频率![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736159978350-bcd96858-f40a-4976-a71b-5cbe29d633a2.png)
                2. shutdown触发，保证服务器正常关闭
                3. flushall触发备份，单rdb文件是空的
            2. 手动触发
                1. save
                2. bgsave
        2. RDB的优势
            1. **<font style="color:#DF2A3F;">RDB是一个非常紧凑（compact）的文件，它保存了redis在某个时间点上的数据集</font>**。非常适用于进行备份和灾难恢复
            2. **<font style="color:#DF2A3F;">生成RDB文件时，Redis主进程会fork一个子进程来处理所有保存工作，主进程不需要进行任何磁盘工作</font>**
            3. **<font style="color:#DF2A3F;">RDB在恢复大数据集时的速度比AOF的更快</font>**
        3. RDB的劣势
            1. **<font style="color:#DF2A3F;">没办法做到实时持久化</font>**。因为bgsave每次运行都要执行fork创建子进程，执行成本过高
            2. 在一定间隔时间做一次备份，如果redis意外down掉，就会丢失最后一次快照之后的所有修改
    5. AOF（Append Only File）
        1. <font style="color:#DF2A3F;">默认不开启</font>。**<font style="color:#DF2A3F;">AOF采用日志的形式来记录每个操作，并追加到文件中</font>**。只要执行Redis命令，就会把命令写入到AOF文件中
        2. <font style="color:#DF2A3F;">数据都是实时持久化到磁盘的吗</font>？
            1. 由于操作系统的缓存机制，AOF数据并没有实时地写入硬盘，而是进入了系统的硬盘缓存。什么时候把缓冲区的内容写入到AOF文件？![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736173871403-bbad0b21-3aa3-4cbe-b53b-e0dcdbdd7e57.png)
        3. <font style="color:#DF2A3F;">文件越来越大怎么办</font>？
            1. 随着AOF的文件越来越大，文件越大，占用服务器内存越来越大以及AOF恢复时间越长。可能会出现一个问题：记录的命令很多都是重复的，有效的结果很少。为了解决这个问题，Redis增加了重写机制，**<font style="color:#DF2A3F;">当AOF文件的大小超过设定的阈值时，Redis就会启动AOF内容压缩，只保留最小的指令集。</font>**
            2. 可以使用bgrewriteaof命令重写
            3. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736174395394-e9cf5991-3457-49c2-b9ec-f3885dd04a3e.png)
        4. <font style="color:#DF2A3F;">重写过程中，AOF文件被更改怎么办</font>？
            1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736174456634-fd9efd86-f358-4b6b-a567-234a12e7f5f5.png)
        5. AOF的优势
            1. **<font style="color:#DF2A3F;">AOF提供多种同步频率，即使使用默认的同步频率每秒同步一次，Redis最多也就丢失1秒的数据</font>**
        6. AOF缺点
            1. 对具有相同的数据，**<font style="color:#DF2A3F;">AOF的文件通常会比RDB文件体积大</font>**，
    6. <font style="color:#DF2A3F;">RDB和AOF如何选择</font>？
        1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736174756906-80259748-86fd-4f00-b8e4-0f31ffa5ed6c.png)

#### Redis高级应用
高性能、高可用、扩展性方案主要依赖两种技术：分片和冗余。分片就是把数据拆分到多个节点存储；冗余就是每个节点都有一个或者多个副本。

##### Redis主从复制
    1. 主从复制原理
        1. 连接阶段，salve节点启动时，会在自己本地保存master节点的信息，包括master node的host和port；slave内部有个定时任务，每隔1秒会检查是否有新master要连接和复制；为了让主节点感知slave节点，slave会定时向主节点发送ping请求
        2. 数据同步阶段
            1. 如果是新加入的slave节点，需要全量复制。master通过bgsave命令在本地生成一份RDB快照发送给slave。
            2. **<font style="color:#DF2A3F;">如果slave节点自己本来有数据怎么办？</font>**slave节点首先需要清除自己数据，然后用RDB快照加载数据
            3. <font style="color:#DF2A3F;">master节点成成RDB期间，接收到的写命令怎么处理</font>？开始生成RDB文件时，master会把所有新的写命令放入缓存。在slave节点保存了RDB之后，再将新的写命令复制给slave节点（跟AOF 重写rewrite期间接收到新命令的处理思路一样）
        3. 命令传播阶段
            1. master持续把写命令，异步复制给slave 节点
        4. **<font style="color:#DF2A3F;">主从复制的不足：</font>**
            1. 没有解决高可用问题，如果master节点挂了，对外提供的服务就不可用，没有解决单点问题
            2. 每次都是手动把之前的从节点改为主节点，比较费时费力，会造成一定服务不可用
        5. 其他
            1. slave节点通过master_repl_offset记录偏移量，避免全量复制
            2. Redis6.0的一个新特性，为了降低主节点的磁盘开销。主从复制的无盘复制，master生成的RDB文件不保存到磁盘，而是直接通过网络发送给从节点。

##### Sentinel 哨兵
    2. **<font style="color:#DF2A3F;">Redis通过Sentinel（哨兵）来解决高可用</font>**。为了保证监控服务器的可用性，我们会对Sentinel做集群的部署。Sentinel即监控所有Redis服务，Sentinel之间也相互监控。![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736237490772-73f34110-aecd-4c9f-b8b2-4e8be31dec15.png)
    3. Sentinel本身没有主从之分，地位平等，只有Redis节点之间有主从之分；<font style="color:#DF2A3F;">Sentinel是一个特殊状态的Redis节点，具有发布订阅功能；哨兵在上线时，给所有Redis节点的名字为：_sentinel_:hello的channel发送消息，所以能相互感知对方的存在，而进行监控</font>。
    4. Sentinel的主要作用：<font style="color:#DF2A3F;">感知Redis节点服务的状态</font>和<font style="color:#DF2A3F;">故障迁移</font>
        1. 感知master节点下线
            1. Sentinel默认以每秒1次的频率向Redis服务节点发送PING命令，如果在指定的时间内（默认30s）没收到有效回复，Sentinel将该服务标记下线（<font style="color:#DF2A3F;">主观下线</font>）
            2. 但是，只有你发现master下线了，并不代表master真的下线了。该Sentinel会询问其他的Sentinel节点，如果多数的Sentinel都认为该master下线，master才真正下线（<font style="color:#DF2A3F;">客观下线</font>）
        2. 故障迁移
            1. Redis的选举和故障迁移是由Sentinel完成的；故障迁移第一步就是选举一个Leader，由Leader完成故障迁移流程，Sentinel通过Raft算法完成选举。
            2. Raft算法是一个共识算法，核心思想是：先到先得，少数服从多数。Raft选举Leader过程：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736239796756-8837e013-8af9-4513-89d4-27f6b5d5ef7b.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736239839210-04e88988-117e-4346-ad48-dd43d6ba4023.png)
            3. Reids的Raft算法和Raft论文有所不同：
                1. master的客观下线触发选举，而不是通过election timeout的时间开始选举
                2. Leader并不会把自己成为Leader的消息发送给其他Sentinel，其他Sentinel等待Leader选出master后，检测到新的master正常工作后，就会去掉客观下线标识，不需要进入故障转移流程。
            4. 完成上面的步骤，我们只是从Sentinel节点里面选举出一个Leader，下面是从slave节点选举出master节点规则：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736240034580-3b475272-74aa-4f1a-9f1b-09d0240297da.png)
            5. 确定master节点后，如何让其他的节点变成他的从节点呢？选举出master后，由Sentinel Leader 向某个节点发送slaveof no one命令，让它成为独立节点；然后向其他节点发送slaveof x.x.x.x xxxx（本机IP端口），让他们成为这个节点的从节点，故障转移完成。
    5. Sentinel的不足：
        1. 主从切换的时候，会有数据丢失，因为只有一个master
        2. 只能单点写，没有解决水平扩容问题

##### Redis分布式方案
第一种在客户端实现先关逻辑，例如使用一致性哈希对key进行分片；

第二种把分片处理的逻辑抽取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求转发；

第三种是基于服务端实现；

###### 客户端分片
        1. 普通哈希，hash(key)%N，根据余数，决定映射到哪一个节点。这种方式比较简单属于静态的分片规则，一旦节点数量发生变化，由于取模的N发生变化，数据需要重新分配。未解决这个问题，我们有一致性哈希算法。
        2. 一致性哈希的原理：
            1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736322870890-d248cf03-23b4-4d87-993a-49c9c0c313c5.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736322921165-ec625e20-f9e7-4aa4-91a8-e77b95b1ea3f.png)
            2. **<font style="color:#DF2A3F;">一致性哈希动态增减节点，只会影响到相邻节点，对其他节点没有影响</font>**。但是一致性哈希有一个问题，因为节点不是均匀分布的，特别是节点比较少的情况下，数据不能均匀的分布。解决这个问题的办法就是引入虚拟节点。![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736324582175-0f675c55-2e52-4344-ace2-47190c9b8aef.png)

###### 代理分片
        3. 存在不足：
            1. 代理架构一般需要借助其他的组件，出现故障不能自主转移，机构复杂。
            2. 扩缩容需要修改配置，不能平滑的扩缩容
        4. 常见的代理中间件：Codis、Twemproxy
        5. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736330441870-ddc8f162-1f23-4cb9-87f9-860162402a5f.png)

###### Redis Cluster
        1. 用来解决高可用，是一个去中心化的架构。以3主3从为例，节点之间两两交互，共享数据分片和节点状态等信息。
        2. Cluster怎么解决分片问题，数据怎么分布？
            1. Cluster没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现。Redis创建了16384个槽（slot），每个节点负责一定区域的slot，例如：![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736332634302-7c93eb02-7985-4fd4-aaf4-0d5ce2276e64.png)
            2. 对象分布到Redis节点时，对key做CRC16算法计算再%16384，得到一个slot的值，数据落到负责这个slot的节点上。Redis中每个master节点都会维护自己负责的slot。
            3. <font style="color:#DF2A3F;">key和slot的关系是永远不会变的，会变的只是slot和redis节点的关系。</font>
        3. **<font style="color:#DF2A3F;">怎么让相关联的数据落到同一个节点上？</font>**
            1. 比如有些multi key操作是不能跨节点的，需要落到同一个节点。**<font style="color:#DF2A3F;">在key中加入{hash tag}即可。Redis在计算槽编号的时候只会取{}中的字符串进行槽编号计算</font>**，{}中的字符串是相同的，因此他们会落到同一个槽。![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736333294603-48057b46-47bf-4109-a105-429efcde8b7b.png)
        4. **<font style="color:#DF2A3F;">客户端连接到哪一台服务器？访问的数据不在当前节点上怎么办？</font>**
            1. 服务端返回MOVED，根据key计算出来的slot不归某个节点管理时，服务端会返回具体的节点端口![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736333513960-0386e531-d5e8-471f-93cf-be6decb77e9e.png)
        5. 新增或下线了master节点，数据怎么迁移？
            1. 因为key和slot的关系是永远不变的，新增了节点需要把原有的slot分配给新的节点，并把相关的数据迁移过来。
        6. 只有主节点可以写，一个主节点挂了，从节点怎么变成主节点？
            1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736333815163-a2f35bd4-ad1f-4a16-ae60-6dd72dc880bf.png)
        7. Redis Cluster的特点
            1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736333907226-269e0481-7c20-40df-b9b7-d3137434adfd.png)

#### Redis实战
###### 常见Redis客户端
    1. Jedis
        1. Jedis最常见的客户端。
        2. 存在不足地方：多线程使用一个连接的时候线程不安全。解决思路：使用连接池，为每个请求创建不同的连接。
    2. Lettuce
        1. 克服了线程不安全问题，Lettuce是一个可伸缩的线程安全的Redis客户端，多个线程可以共享一个线程示例。
    3. Redisson
        1. 是一个在Redis的基础上实现的Java内存数据网格，提供了分布式和可扩展的Java数据结构。比如分布式的Map、List等
        2. Redisson使用分布式锁的实现原理：
            1. 最终也是调用一段Lua脚本。
            2. 业务没执行完，锁到期了怎么办？答：watch dog，类似存在定时检查锁的过期时间，不断续命。
            3. 集群模式下，如果对多个master加锁，导致重复加锁怎么办？Redisson会自动选择同一个master。

###### 数据一致性
    1. 我们的原则：数据最终以数据库为准。
    2. 如果我们既要操作数据库，也要操作Redis，存在两种选择：
        1. 先操作Redis数据再操作数据库数据
        2. 先操作数据库数据再操作Redis数据
        3. <font style="color:#DF2A3F;">Redis数据：删除还是更新</font>？主要考虑缓存的代价，如果更新缓存之前，需要经过其他表的查询、接口调用和复杂的计算，建议直接删除缓存，这种方案更加简单。
        4. <font style="color:#DF2A3F;">先删除缓存，再更新数据库</font>
            1. 正常情况，缓存删除成功，数据库成功
            2. 异常情况
                1. 删除缓存失败，程序捕获异常，不会走到下一步，不会出现数据不一致
                2. 删除缓存成功，更新数据库失败。因为以数据库数据为准，所以不存在数据不一致问题
                3. 数据并发的情况：
                    1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736414369001-cdb75f60-3b38-43c0-afbf-cd2eedf659d2.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736414387002-57a3d765-0a04-4a4d-bdbf-fbefe114ab92.png)
                    2. 解决办法：使用延时双删的策略，在写入数据后，再删除一次缓存。
                        1. A线程：删除缓存
                        2. 更新数据库
                        3. 休眠500ms（这个时间依据读取数据时间）
                        4. 再次删除缓存
        5. <font style="color:#DF2A3F;">先更新数据库，再删除缓存</font>
            1. 正常情况下：更新数据库成功，删除缓存成功
            2. 异常情况：
                1. 更新数据库失败，程序捕获异常，不会走到下一步，不会出现数据不一致
                2. 更新数据库成功，删除缓存失败。数据库是新数据，缓存是旧数据，出现缓存不一致。
                3. 解决办法：
                    1. 第一种方案：删除缓存失败，可以捕获异常，将key发送到消息队列进行重试。但是会造成代码入侵
                    2. 第二种方案：通过服务来监听binlog，例如（阿里的canal）在服务端完成删除key的操作，如果失败再发送消息队列。
                    3. 总之对删除缓存失败，做法都是不断尝试删除，直到成功

###### 高并发问题
    3. 热点数据发现，如何找出高频率的Key？
        1. 第一种客户端统计，对set/get命令进行记数
        2. 第二种在代理层实现计数
        3. 第三种在服务端统计，Redis有一个monitor命令，可以监控Redis执行命令。facebook的开源项目redis-faina就是基于这个原理实现
    4. **<font style="color:#DF2A3F;">缓存雪崩</font>**
        1. 缓存雪崩就是Redis的大量热点数据同时过期（失效），因为设置了相同的过期时间，导致并发量大的时所有请求都落到数据库。
        2. 解决方案：
            1. 在高并发时进行限流，使用互斥锁或者队列，针对同一个key只允许一个线程查询数据库
            2. 缓存预热，避免同时失效
            3. 设置随机过期时间
            4. 数据永不过期
    5. 缓存击穿
        1. <font style="color:#DF2A3F;">略</font>
    6. **<font style="color:#DF2A3F;">缓存穿透</font>**
        1. **<font style="color:#DF2A3F;">缓存穿透指的是查询一个不存在的数据，缓存层和持久层都不会命中</font>**，导致每次请求都落到持久层。
        2. 解决方案：
            1. **<font style="color:#DF2A3F;">缓存空数据、缓存特殊字符串，比如：&&</font>**
            2. **<font style="color:#DF2A3F;">布隆过滤器</font>**：
                1. <font style="color:#DF2A3F;">布隆过滤器的本质就是：一个位数组和若干个哈希函数</font>
                2. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736497202720-395cbbe9-f180-4595-a5c4-a71e5daef2cb.png)![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736497216513-9d0948e2-3797-4609-a622-cac7f1153094.png)	![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736497252468-f7e17b89-45fd-4374-8acb-174c5ca34747.png)
                3. **<font style="color:#DF2A3F;">布隆过滤器的特点：</font>**
                    1. **<font style="color:#DF2A3F;">如果布隆过滤器判断元素在集合中存在，不一定存在</font>**
                    2. **<font style="color:#DF2A3F;">如果布隆过滤器判断不存在，一定不存在</font>**
                4. 使用布隆过滤器解决缓存穿透
                    1. ![](https://cdn.nlark.com/yuque/0/2025/png/35576929/1736497446182-2c75f1ad-f400-4ef5-b1cd-c83bffe47517.png)

